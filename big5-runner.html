<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Big 5 Runner</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body,html{height:100%;overflow:hidden;background:#000;font-family:Arial}
  canvas{display:block;margin:auto;background:transparent;image-rendering:pixelated;position:relative;z-index:1}
  /* Logo overlay (separate from background) */
  #siteLogo{position:fixed;top:8px;left:8px;height:64px;z-index:2000;pointer-events:none;transition:height 180ms ease,transform 180ms ease;display:block}
  @media (max-width:480px){
    #siteLogo{height:40px}
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<!-- Site logo (separate from background). Provide a `logo.png` in the same folder. -->
<img id="siteLogo" src="logo.png" alt="logo" style="position:fixed;top:8px;left:8px;height:64px;z-index:2000;pointer-events:none;transition:height 180ms ease,transform 180ms ease;display:block"> 
<!-- Language switch (small pills next to the logo) -->
<div id="langSwitch" style="position:fixed;top:12px;left:86px;z-index:2001;display:flex;gap:6px">
  <button id="langEn" style="background:#fff;border:1px solid rgba(0,0,0,0.08);border-radius:999px;padding:6px 8px;font-weight:700;cursor:pointer">EN</button>
  <button id="langIt" style="background:transparent;border:1px solid rgba(0,0,0,0.08);border-radius:999px;padding:6px 8px;font-weight:700;cursor:pointer">IT</button>
</div>

<!-- Fullscreen language picker shown before the user chooses a language -->
<div id="languageOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.6));z-index:3000">
  <div style="background:#fff;border-radius:12px;padding:28px;max-width:520px;width:92%;box-shadow:0 12px 40px rgba(0,0,0,0.4);text-align:center;font-family:Roboto,Arial,sans-serif;color:#202124">
    <h1 id="langOverlayTitle" style="margin:0 0 12px;font-size:22px">Choose your language</h1>
    <p id="langOverlaySubtitle" style="margin:0 0 20px;color:#5f6368">Select the language you prefer to play in.</p>
    <div style="display:flex;gap:14px;justify-content:center;flex-wrap:wrap">
      <button id="chooseEn" style="min-width:140px;padding:12px 16px;border-radius:8px;border:none;background:#1a73e8;color:#fff;font-weight:700;font-size:16px;cursor:pointer">English</button>
      <button id="chooseIt" style="min-width:140px;padding:12px 16px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);background:transparent;color:#202124;font-weight:700;font-size:16px;cursor:pointer">Italiano</button>
    </div>
    <div style="margin-top:18px;color:#5f6368;font-size:13px">You can change language later using the small language pills.</div>
  </div>
</div>
<!-- debug UI removed -->
<!-- Fun facts container (hidden until game starts). Will be positioned next to the logo on desktop, below it on mobile -->
<div id="funFactsContainer" style="display:none;position:fixed;z-index:2000;pointer-events:auto">
  <div id="funFactCard" style="background:#fff;color:#202124;border-radius:12px;box-shadow:0 6px 18px rgba(60,64,67,0.15);border:1px solid rgba(60,64,67,0.08);padding:12px 14px;max-width:380px;font-family:Roboto,Arial,sans-serif">
      <div id="funFactTitle" style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
        <div style="width:36px;height:36px;border-radius:8px;background:linear-gradient(135deg,#1a73e8,#4285f4);display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:16px">i</div>
        <div id="funFactTitleText" style="font-weight:700;color:#202124;font-size:14px">Did you know?</div>
      </div>
    <div id="funFactText" style="font-size:13px;line-height:1.3;color:#3c4043">Fun fact will appear here.</div>
  </div>
</div>
<div id="bg" style="position:fixed;inset:0;background:#fafafa;background-size:cover;background-position:center;/* no blur - images already blurred */transform:scale(1.03);z-index:0;transition:opacity 500ms ease-in-out;opacity:1"></div>
<div id="overlay" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:10000">
  <div id="overlayBox" style="background:rgba(0,0,0,0.6);color:#fff;padding:20px 28px;border-radius:8px;font-family:Arial,monospace;font-size:18px;pointer-events:auto;display:none;max-width:420px">
    <div id="overlayText">Game Over</div>
    <div id="nameEntry" style="margin-top:12px;display:none">
      <div style="font-size:14px;color:#ddd;margin-bottom:6px">New high score! Enter your name:</div>
      <input id="nameInput" type="text" placeholder="Your name" style="padding:8px;border-radius:4px;border:1px solid #444;background:#fff;color:#000;width:100%;box-sizing:border-box;margin-bottom:8px">
      <div style="display:flex;gap:8px;justify-content:flex-end"><button id="saveNameBtn" style="padding:8px 12px;border-radius:4px;border:none;background:#2ecc71;color:#000;font-weight:700">Save</button></div>
    </div>
    <div id="overlayPress" style="margin-top:8px;font-size:13px;color:#ddd">Press SPACE to play again</div>
  </div>
</div>
<script>
// Debugging disabled in production UI
function dbg(msg) { /* no-op debug */ }
dbg('script start');
window.addEventListener('error', e => {});
window.addEventListener('unhandledrejection', e => {});
// Canvas
const canvas = document.getElementById('c');
if(!canvas){ dbg('Canvas element not found'); }
const ctx = canvas.getContext('2d');
if(!ctx){ dbg('2D context not available'); }
function resize(){
  const dpr = window.devicePixelRatio||1;
  canvas.width = innerWidth*dpr;
  canvas.height = innerHeight*dpr;
  canvas.style.width = innerWidth+'px';
  canvas.style.height = innerHeight+'px';
  // avoid touch gestures on canvas causing scroll/zoom on some devices
  try{ canvas.style.touchAction = 'none'; }catch(e){}
  // Reset transform then set proper devicePixelRatio scale (avoid cumulative scaling)
  if (ctx.setTransform) ctx.setTransform(dpr,0,0,dpr,0,0);
  else ctx.scale(dpr,dpr);
  // don't reference `game` here — it may not be initialized yet
  dbg(`resize dpr=${dpr} cssx=${innerWidth}x${innerHeight} canvasPx=${canvas.width}x${canvas.height}`);

  // Responsive: adjust logo size/position when resizing
  try{
    const logo = document.getElementById('siteLogo');
    if(logo){
      if(window.innerWidth <= 480){
        logo.style.height = '40px';
        logo.style.left = '8px';
        logo.style.top = '8px';
      } else {
        logo.style.height = '64px';
        logo.style.left = '8px';
        logo.style.top = '8px';
      }
    }
  }catch(e){}
}
resize();
window.addEventListener('resize',resize);
window.addEventListener('resize', layoutFunFacts);

// Show language overlay if language not selected yet
function showLanguageOverlayIfNeeded(){
  const overlay = document.getElementById('languageOverlay');
  if(!overlay) return;
  // if user already chose language previously, don't show
  try{ const saved = localStorage.getItem(LANG_KEY); if(saved) { overlay.style.display='none'; return; } }catch(e){}
  overlay.style.display = 'flex';
}
showLanguageOverlayIfNeeded();

// wire overlay buttons
const chooseEn = document.getElementById('chooseEn');
const chooseIt = document.getElementById('chooseIt');
function pickLang(lang){ currentLang = lang; try{ localStorage.setItem(LANG_KEY, lang); }catch(e){} updateLangUI(); const overlay = document.getElementById('languageOverlay'); if(overlay) overlay.style.display='none'; }
if(chooseEn) chooseEn.addEventListener('click', ()=> pickLang('en'));
if(chooseIt) chooseIt.addEventListener('click', ()=> pickLang('it'));

// Game state
let game = {running:false, speed:0, score:0, frame:0, ground:0, groundOffset:0, spawnCooldown:0};
let player = {x:80, y:0, vy:0, jumping:false, crouching:false, frame:0, tick:0};
let obstacles = [];

// Animals and park backgrounds
const animals = ['Lion','Leopard','Buffalo','Elephant','Rhino'];
let animalId = Math.floor(Math.random()*animals.length);
// Always use a single park background file when true (use `N.png` in project root)
const USE_SINGLE_PARK = true;
const SINGLE_PARK_INDEX = 1; // set to 1, 2, or 3 to choose which root-numbered background to use
const parkQueries = {
  'Lion':'masai mara national reserve kenya',
  'Leopard':'samburu national reserve kenya',
  'Buffalo':'tsavo national park kenya',
  'Elephant':'amboseli national park kenya',
  'Rhino':'lake nakuru national park kenya'
};
// list of parks for random background selection (broader list)
const parks = [
  'masai mara national reserve kenya',
  'samburu national reserve kenya',
  'tsavo national park kenya',
  'amboseli national park kenya',
  'lake nakuru national park kenya',
  'ol pejeta conservancy kenya',
  'meru national park kenya',
  'samburu kenya landscape',
  'mount kenya national park kenya',
  'hells gate national park kenya'
];
const colors = ['#000','#000','#000','#000','#000']; // silhouettes are black

// try to load per-animal local silhouette images from the current folder first,
// then check common subfolders like ./animals/ or ./animal/ or ./silhouettes/
const silImages = {};
function loadSilhouettes(){
  // First try numbered files (1..N) matching the animals array order
  animals.forEach((name, idx) => {
    const num = idx + 1;
    // build candidates for several common extensions and locations
    // NOTE: do NOT treat project-root numeric files (1/2/3) as animal images.
    // Numeric files are reserved for park backgrounds. Only use name-based
    // image files for animal silhouettes, and fall back to subfolders.
    const exts = ['.png', '.jpg', '.jpeg', '.webp'];
    const candidates = [];
    // root-name variants (try lowercase and exact name)
    exts.forEach(ext => {
      candidates.push(`${name.toLowerCase()}${ext}`);
      candidates.push(`${name}${ext}`);
    });
    // fallbacks in common subfolders
    exts.forEach(ext => {
      candidates.push(`animals/${name.toLowerCase()}${ext}`);
      candidates.push(`animal/${name.toLowerCase()}${ext}`);
      candidates.push(`silhouettes/${name.toLowerCase()}${ext}`);
    });

    (function tryNext(i){
      if(i >= candidates.length){ dbg('no local silhouette found for: '+name); return; }
      const file = candidates[i];
      const img = new Image();
      img.onload = () => { silImages[name] = img; dbg('loaded silhouette: '+file); };
      img.onerror = () => { tryNext(i+1); };
      img.src = file;
    })(0);
  });
}
loadSilhouettes();

// Input
let keys = {};
let spacePressed = false;
window.addEventListener('keydown', e => {
  if (e.key === ' ') {
    e.preventDefault();
    if (!spacePressed) {
      spacePressed = true;
      if (!game.running) start();
      else if (!player.jumping) jump();
    }
  }
  keys[e.key] = true;
});
window.addEventListener('keyup', e => {
  if (e.key === ' ') spacePressed = false;
  keys[e.key] = false;
});

// Touch / pointer support for mobile: tap to jump / start
function onPointerDown(e){
  // prevent default to avoid page scrolling on touch
  if(e && e.preventDefault) e.preventDefault();
  if (!spacePressed) {
    spacePressed = true;
    if (!game.running) start();
    else if (!player.jumping) jump();
  }
}
function onPointerUp(e){
  if(e && e.preventDefault) e.preventDefault();
  spacePressed = false;
}
window.addEventListener('touchstart', onPointerDown, {passive:false});
window.addEventListener('touchend', onPointerUp, {passive:false});
window.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointerup', onPointerUp);

const bgEl = document.getElementById('bg');
const overlayBox = document.getElementById('overlayBox');
const overlayText = document.getElementById('overlayText');

function setBackgroundForAnimal(id){
  // If configured to use a single park, always use that park for the
  // background (try local numbered files for that park first, then
  // fallback to Unsplash for that park). Otherwise, pick a park based on
  // the animal (preferred park usually) or random fallback.
  bgEl.style.opacity = 0;
  if (typeof USE_SINGLE_PARK !== 'undefined' && USE_SINGLE_PARK) {
    const parkNum = Math.max(1, Math.min(3, Number(SINGLE_PARK_INDEX) || 1));
    // Use only the root file `N.png` for the park (no Unsplash fallback).
    const file = `${parkNum}.png`;
    const img = new Image();
    img.onload = () => {
      bgEl.style.backgroundImage = `url(${file})`;
      // responsive adjustments
      bgEl.style.backgroundSize = 'cover';
      bgEl.style.backgroundPosition = window.innerWidth <= 480 ? 'center top' : 'center center';
      bgEl.style.transform = window.innerWidth <= 480 ? 'scale(1)' : 'scale(1.03)';
      bgEl.style.opacity = 1;
      dbg('using local park image: '+file);
      // update fun fact for this numbered park
      setFunFactForFilename(file);
    };
    img.onerror = () => {
      dbg('local park image '+file+' not found; keeping previous background');
      // keep previous background visible; do not fall back to Unsplash or neutral fill
      bgEl.style.opacity = 1;
    };
    img.src = file;
    return;
  }

  // non-single-park behavior (pick based on animal)
  const name = animals[id];
  const preferred = parkQueries[name];
  const usePreferred = Math.random() < 0.7; // usually use the preferred park
  const q = usePreferred && preferred ? preferred : parks[Math.floor(Math.random()*parks.length)];
  const parkExts = ['.png','.jpg','.jpeg','.webp'];
  const localImages = [];
  [1,2,3].forEach(n => parkExts.forEach(ext => localImages.push(`${n}${ext}`)));
  [1,2,3].forEach(n => parkExts.forEach(ext => localImages.push(`parks/${n}${ext}`)));
  const localChoice = localImages[Math.floor(Math.random()*localImages.length)];
  const img = new Image();
  img.onload = () => {
    bgEl.style.backgroundImage = `url(${localChoice})`;
    bgEl.style.backgroundSize = 'cover';
    bgEl.style.backgroundPosition = window.innerWidth <= 480 ? 'center top' : 'center center';
    bgEl.style.transform = window.innerWidth <= 480 ? 'scale(1)' : 'scale(1.03)';
    bgEl.style.opacity = 1;
    dbg('using local park image: '+localChoice + ' -> bgEl.backgroundImage=' + bgEl.style.backgroundImage);
    // update fun fact if this is a numbered park file
    setFunFactForFilename(localChoice);
  };
  img.onerror = () => {
    dbg('local park image failed, falling back to Unsplash for: '+q);
    const url = 'https://source.unsplash.com/1600x900/?' + encodeURIComponent(q);
    const img2 = new Image();
    img2.crossOrigin = 'anonymous';
    img2.onload = () => {
      bgEl.style.backgroundImage = `url(${url})`;
      bgEl.style.backgroundSize = 'cover';
      bgEl.style.backgroundPosition = window.innerWidth <= 480 ? 'center top' : 'center center';
      bgEl.style.transform = window.innerWidth <= 480 ? 'scale(1)' : 'scale(1.03)';
      bgEl.style.opacity = 1;
      dbg('using Unsplash image: '+url + ' -> bgEl.backgroundImage=' + bgEl.style.backgroundImage);
      // Unsplash fallback does not have a numbered filename, clear fun fact
      setFunFactForIndex(null);
    };
    img2.onerror = () => {
      dbg('Unsplash fallback failed; keeping previous background (no neutral fill)');
      bgEl.style.opacity = 1;
    };
    img2.src = url;
  };
  img.src = localChoice;
}
setBackgroundForAnimal(animalId);

// --- Highscore and Fun Fact support ---
const HIGHSCORE_KEY = 'big5_highscore_v1';
function loadHighscore(){
  try{
    const raw = localStorage.getItem(HIGHSCORE_KEY);
    if(!raw) return {score:0,name:'---'};
    return JSON.parse(raw);
  }catch(e){ return {score:0,name:'---'}; }
}
function saveHighscore(name,score){
  const payload = {name:name||'Player',score:score};
  try{ localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(payload)); }catch(e){ dbg('failed saving highscore: '+e); }
  updateHighscoreDisplay();
}
function updateHighscoreDisplay(){
  const hs = loadHighscore();
  const elName = document.getElementById('hsName');
  const elScore = document.getElementById('hsScore');
  if(elName) elName.textContent = hs.name || '---';
  if(elScore) elScore.textContent = hs.score != null ? hs.score : 0;
}

// Fun facts per park (each park has multiple facts to rotate)
const parkFacts = {
  1: [
    'Masai Mara: Known for the Great Migration — millions of wildebeest, zebra and gazelle pass through each year.',
    'Masai Mara: Home to the Big Five — lion, leopard, elephant, rhino and buffalo.',
    'Masai Mara: It borders the Serengeti in Tanzania, creating a large transboundary ecosystem.'
  ],
  2: [
    'Tsavo: One of Kenya\'s largest parks, famous for wide-open plains and large elephant populations.',
    'Tsavo: Historically known as the “land of red elephants” because of the reddish dust that coats animals there.',
    'Tsavo: It\'s actually two parks (East and West) connected by wildlife corridors.'
  ],
  3: [
    'Amboseli: Famous for its views of Mount Kilimanjaro and large herds of free-ranging elephants.',
    'Amboseli: Known for excellent elephant photography — the park has plains and wetlands.',
    'Amboseli: Local Maasai communities live around the park and play a role in conservation.'
  ]
};

// current fun facts state
let currentFunFacts = [];
let currentFunIndex = 0;
let funFactsInterval = null;

function setFunFactForIndex(n){
  currentFunFacts = parkFacts[n] || [];
  currentFunIndex = 0;
  if(currentFunFacts.length > 0) showFunFact(currentFunFacts[0]);
}

function setFunFactForFilename(filename){
  if(!filename) return;
  const m = filename.match(/(?:^|\/)\s*([123])(?:\.|$)/);
  if(m) setFunFactForIndex(Number(m[1]));
}

// Simple i18n support for English and Italian
let currentLang = 'en';
const i18n = {
  en: {
    didYouKnow: 'Did you know?',
    newHighScorePrompt: 'New high score! Enter your name:',
    pressSpace: 'Press SPACE to play again',
    gameOver: 'Game Over! Score:'
  },
  it: {
    didYouKnow: 'Lo sapevi?',
    newHighScorePrompt: 'Nuovo record! Inserisci il tuo nome:',
    pressSpace: 'Premi SPAZIO per giocare di nuovo',
    gameOver: 'Fine del gioco! Punteggio:'
  }
};

// localized park facts (same structure as parkFacts but per language)
const parkFacts_i18n = {
  en: parkFacts,
  it: {
    1: [
      'Masai Mara: Conosciuta per la Grande Migrazione — milioni di gnu, zebre e gazzelle che la attraversano ogni anno.',
      'Masai Mara: Ospita i Big Five — leone, leopardo, elefante, rinoceronte e buffalo.',
      'Masai Mara: Confina con il Serengeti in Tanzania, creando un grande ecosistema transfrontaliero.'
    ],
    2: [
      'Tsavo: Uno dei parchi più grandi del Kenya, famoso per le pianure e le grandi popolazioni di elefanti.',
      'Tsavo: Storicamente noto come «terra degli elefanti rossi» a causa della polvere rossastra.',
      'Tsavo: In realtà è composto da due parchi (Est e Ovest) collegati da corridoi per la fauna.'
    ],
    3: [
      'Amboseli: Famoso per le sue vedute del Kilimanjaro e le grandi mandrie di elefanti.',
      'Amboseli: Conosciuto per l\'eccellente fotografia degli elefanti — il parco ha pianure e zone umide.',
      'Amboseli: Le comunità Maasai vivono intorno al parco e partecipano alla conservazione.'
    ]
  }
};

function t(key){ return (i18n[currentLang] && i18n[currentLang][key]) || i18n['en'][key] || '' }

// Persisted language preference key
const LANG_KEY = 'big5_lang_v1';
// load saved language if present
try{ const saved = localStorage.getItem(LANG_KEY); if(saved) currentLang = saved; }catch(e){}

function showFunFact(text){
  const el = document.getElementById('funFactText');
  if(!el) return;
  el.textContent = text || '';
}

function startFunFactsRotation(){
  stopFunFactsRotation();
  if(!currentFunFacts || currentFunFacts.length === 0) return;
  funFactsInterval = setInterval(()=>{
    currentFunIndex = (currentFunIndex + 1) % currentFunFacts.length;
    showFunFact(currentFunFacts[currentFunIndex]);
  }, 10000); // rotate every 10s
}

function stopFunFactsRotation(){
  if(funFactsInterval){ clearInterval(funFactsInterval); funFactsInterval = null; }
}

function layoutFunFacts(){
  const container = document.getElementById('funFactsContainer');
  const logo = document.getElementById('siteLogo');
  if(!container || !logo) return;
  const lr = logo.getBoundingClientRect();
  if(window.innerWidth <= 480){
    // mobile: below logo, full width minus margins
    container.style.left = '8px';
    container.style.top = (lr.bottom + 8) + 'px';
    container.style.right = '';
    const card = document.getElementById('funFactCard'); if(card) card.style.maxWidth = 'calc(100% - 16px)';
  } else {
    // desktop: to the right of logo
    container.style.top = (lr.top) + 'px';
    container.style.left = (lr.right + 12) + 'px';
    container.style.right = '';
    const card = document.getElementById('funFactCard'); if(card) card.style.maxWidth = '380px';
  }
}

function startFunFacts(){
  const container = document.getElementById('funFactsContainer');
  if(container){ container.style.display = 'block'; }
  layoutFunFacts();
  // ensure facts are taken from the correct language set
  currentFunFacts = (parkFacts_i18n[currentLang] && parkFacts_i18n[currentLang][SINGLE_PARK_INDEX]) || [];
  currentFunIndex = 0;
  if(currentFunFacts.length > 0) showFunFact(currentFunFacts[0]);
  startFunFactsRotation();
}

function stopFunFacts(){
  const container = document.getElementById('funFactsContainer');
  if(container){ container.style.display = 'none'; }
  stopFunFactsRotation();
}

// Initialize highscore display now
updateHighscoreDisplay();

// Start
function start(){
  game.running = true;
  // lower base speed so obstacles aren't too fast initially
  game.speed = 10;
  game.score = 0;
  game.frame = 0;
  player.y = player.vy = 0;
  player.jumping = player.crouching = false;
  obstacles = [];
  // spawn soon after starting so player has something to jump
  game.spawnCooldown = 30;
  overlayBox.style.display = 'none';
  // show and start rotating fun facts for the selected single park
  setFunFactForIndex(SINGLE_PARK_INDEX);
  // update UI text to current language
  const titleEl = document.getElementById('funFactTitleText'); if(titleEl) titleEl.textContent = t('didYouKnow');
  startFunFacts();
  // make overlay input/button larger on small screens for easy tapping
  const ni = document.getElementById('nameInput');
  const sb = document.getElementById('saveNameBtn');
  if(window.innerWidth <= 480){
    if(ni) ni.style.fontSize = '18px';
    if(sb){ sb.style.padding = '12px 16px'; sb.style.fontSize = '16px'; }
  } else {
    if(ni) ni.style.fontSize = '';
    if(sb){ sb.style.padding = ''; sb.style.fontSize = ''; }
  }
}

// Jump
function jump(){
  if (player.jumping) return;
  player.jumping = true;
  // positive vy moves the player upwards (player.y is vertical displacement above ground)
  player.vy = 26;
}

// Spawn obstacle
function spawn(){
  const type = Math.random() < 0.7 ? 'cactus' : 'bird';
  // compute CSS pixels to place obstacle relative to visible canvas size
  const dpr = window.devicePixelRatio||1;
  const cw = canvas.width / dpr;
  const ch = canvas.height / dpr;
  const ground = ch - 100;
  const oW = type==='cactus' ? 40 : 70;
  const oH = type==='cactus' ? 70 : 50;
  obstacles.push({
    // spawn further out so player has time to react
    x: cw + 200,
    y: type==='cactus' ? (ground - oH) : (ground - 80),
    w: oW,
    h: oH,
    type,
    passed: false
  });
}

// Main loop
let last = 0;
function loop(ts){
  const dt = Math.min((ts-last)/16.67,3); last=ts;
  if(game.running) update(dt);
  render();
  requestAnimationFrame(loop);
}

// Update
function update(dt){
  game.frame++;
  game.speed += 0.001*dt;

  // ensure ground is known here (update uses it for collision checks)
  const dpr = window.devicePixelRatio||1;
  const ch = canvas.height / dpr;
  game.ground = ch - 100;

  // Player physics
  if(player.jumping){
    // gravity reduces upward velocity
    player.vy -= 1.8*dt;
    player.y += player.vy*dt;
    // landing when y falls back to 0 or below
    if(player.y <= 0){
      player.y = 0;
      player.jumping = false;
      player.vy = 0;
    }
  }
  player.crouching = keys['ArrowDown'] && player.y === 0;

  // Animation
  player.tick += dt;
  if(player.tick > 6){
    player.tick = 0;
    player.frame = (player.frame+1)%2;
  }

  // Spawn using a cooldown (frame-based) so spacing is easier to control
  if (game.spawnCooldown <= 0) {
    // bias toward ground obstacles so players can jump them
    // sometimes spawn a bird for variety
    const roll = Math.random();
    // make cactus more common
    if (roll < 0.85) {
      spawn();
    } else {
      // force a bird spawn occasionally
      const typeBackup = Math.random();
      // temporary small hack: spawn normally but let spawn() choose type; we'll just call spawn()
      spawn();
    }
    // set next cooldown (frames). As game speeds up, reduce cooldown.
    const minCd = Math.max(20, Math.floor(50 - game.speed));
    const maxCd = Math.max(40, Math.floor(120 - game.speed));
    game.spawnCooldown = Math.floor(minCd + Math.random() * (maxCd - minCd));
  } else {
    game.spawnCooldown--;
  }

  // move ground offset to simulate forward motion
  // slow movement factor to make obstacles/tracking feel less twitchy
  const speedFactor = 0.6;
  game.groundOffset = (game.groundOffset + game.speed*dt*speedFactor) % 40;

  // Move & check obstacles
  for(let i=obstacles.length-1; i>=0; i--){
    const o = obstacles[i];
    // move obstacles using the same reduced speed factor
    o.x -= game.speed*dt*speedFactor;
    if(o.x + o.w < 0) { obstacles.splice(i,1); continue; }

    const ph = player.crouching ? 20 : 32;
    const py = game.ground - player.y - ph;
    if(player.x < o.x+o.w && player.x+32 > o.x && py < o.y+o.h && py+ph > o.y){
      gameOver();
    }

    if(!o.passed && o.x + o.w < player.x){
      o.passed = true;
      game.score++;
    }
  }
}

// Render
function render(){
  const cw = canvas.width/(window.devicePixelRatio||1);
  const ch = canvas.height/(window.devicePixelRatio||1);
  ctx.clearRect(0,0,cw,ch);

  game.ground = ch - 100;
  ctx.fillStyle = '#000';
  // draw moving ground segments to simulate movement
  const segW = 20;
  const off = Math.floor(game.groundOffset % segW);
  for(let x = -off; x < cw; x += segW){
    ctx.fillRect(x, game.ground, Math.floor(segW*0.6), 4);
  }

  // === DISTINCT PIXEL-ART ANIMAL ===
  const baseX = player.x;
  const pH = player.crouching ? 20 : 32; // player height
  const pW = 32; // player width
  // small running bob when on ground so the figure appears to move
  const runBob = (!player.jumping && game.running) ? Math.sin(game.frame*0.35)*2 : 0;
  const baseY = game.ground - player.y - pH + runBob;

  // draw silhouette for current animal
  drawSilhouette(ctx, animals[animalId], baseX, baseY, pW, pH, player.frame);

  // === OBSTACLES ===
  ctx.fillStyle = '#333';
  obstacles.forEach(o => {
    if(o.type === 'cactus'){
      // draw cactus as two columns using its width
      const colW = Math.floor(o.w/2.5);
      ctx.fillRect(o.x, o.y, colW, o.h);
      ctx.fillRect(o.x + (o.w - colW), o.y + 20, colW, Math.max(6, o.h - 40));
    } else {
      const wing = Math.sin(game.frame*0.2)*6;
      // draw bird using its width
      ctx.fillRect(o.x + Math.floor(o.w*0.2), o.y + 20 + wing, Math.floor(o.w*0.6), 12);
      ctx.fillRect(o.x + Math.floor(o.w*0.2), o.y + 36 - wing, Math.floor(o.w*0.6), 12);
    }
  });

  // Score
  ctx.fillStyle = '#000';
  ctx.font = '20px Arial';
  // show stored highscore (left) and current score (right) in the same format
  const hs = (typeof loadHighscore === 'function') ? loadHighscore() : {score:0};
  const hsScore = ('00000'+(hs && hs.score ? hs.score : 0)).slice(-5);
  const curScore = ('00000'+game.score).slice(-5);
  ctx.fillText(`HI ${hsScore}  ${curScore}`, cw-220, 30);
}

// Draw rough silhouettes for each animal. These are stylized shapes (not photo-real),
// but they provide recognizable silhouettes for the Big Five.
function drawSilhouette(ctx, type, x, baseY, w, h, animFrame){
  // Improved silhouette drawing: more detailed and proportional shapes
  ctx.save();
  // if a local image exists for this animal, draw it instead (better realism)
  if(silImages[type]){
    const si = silImages[type];
    // scale image to roughly cover the player's box; keep aspect by using dstH
    const dstH = h * 1.6;
    const dstW = w * 1.8;
    const dx = x - (dstW - w)/2;
    const dy = baseY - (dstH - h);
    ctx.drawImage(si, dx, dy, dstW, dstH);
    ctx.restore();
    return;
  }
  // use white fill with dark shadow to ensure silhouette is visible over varied backgrounds
  ctx.fillStyle = '#fff';
  ctx.translate(x, baseY);
  const scale = (w/32);
  ctx.scale(scale, scale);
  ctx.shadowColor = 'rgba(0,0,0,0.7)';
  ctx.shadowBlur = 6;

  if(type === 'Lion'){
    // more detailed lion silhouette (mane, body, tail)
    ctx.beginPath();
    ctx.moveTo(2,8);
    ctx.bezierCurveTo(6,2,12,0,20,2);
    ctx.bezierCurveTo(26,3,32,8,34,10);
    ctx.bezierCurveTo(35,11,36,13,36,15);
    ctx.bezierCurveTo(36,17,34,20,30,22);
    ctx.bezierCurveTo(24,25,14,26,6,24);
    ctx.bezierCurveTo(2,23,1,20,2,16);
    ctx.closePath();
    ctx.fill();
    // head/mane
    ctx.beginPath(); ctx.arc(31,7,6,0,Math.PI*2); ctx.fill();
    // tail
    ctx.beginPath(); ctx.moveTo(4,14); ctx.quadraticCurveTo(-4,12,-2,8); ctx.lineTo(0,9); ctx.fill();
  } else if(type === 'Leopard'){
    // sleek cat silhouette
    ctx.beginPath();
    ctx.moveTo(2,10);
    ctx.quadraticCurveTo(8,4,16,4);
    ctx.quadraticCurveTo(24,4,30,8);
    ctx.quadraticCurveTo(34,10,35,13);
    ctx.quadraticCurveTo(34,16,30,18);
    ctx.quadraticCurveTo(24,21,16,22);
    ctx.quadraticCurveTo(8,22,4,20);
    ctx.quadraticCurveTo(1,18,2,14);
    ctx.closePath(); ctx.fill();
    // tail
    ctx.beginPath(); ctx.moveTo(4,12); ctx.quadraticCurveTo(-6,8,-2,4); ctx.fill();
  } else if(type === 'Buffalo'){
    // strong body with horns
    ctx.beginPath(); ctx.moveTo(2,14); ctx.quadraticCurveTo(8,6,18,6); ctx.quadraticCurveTo(28,6,34,12);
    ctx.quadraticCurveTo(36,14,36,17); ctx.quadraticCurveTo(36,20,32,22);
    ctx.quadraticCurveTo(24,26,12,26); ctx.quadraticCurveTo(6,26,2,24); ctx.closePath(); ctx.fill();
    // horns
    ctx.beginPath(); ctx.moveTo(32,10); ctx.lineTo(40,6); ctx.lineTo(38,6); ctx.lineTo(34,9); ctx.fill();
  } else if(type === 'Giraffe'){
    // body and long neck
    ctx.beginPath(); ctx.moveTo(2,18); ctx.quadraticCurveTo(10,12,18,12); ctx.quadraticCurveTo(28,12,34,10);
    ctx.quadraticCurveTo(36,9,36,6); ctx.lineTo(36,-6); ctx.quadraticCurveTo(34,-10,30,-10); ctx.quadraticCurveTo(26,-10,24,-6);
    ctx.lineTo(22,-2); ctx.lineTo(20,-6); ctx.lineTo(18,-2); ctx.closePath(); ctx.fill();
    // legs
    ctx.fillRect(4,18,3,8); ctx.fillRect(12,18,3,8); ctx.fillRect(22,18,3,8); ctx.fillRect(30,18,3,8);
  } else if(type === 'Rhino'){
    // heavy body and horn
    ctx.beginPath(); ctx.moveTo(2,14); ctx.quadraticCurveTo(10,8,20,8); ctx.quadraticCurveTo(28,8,34,12);
    ctx.quadraticCurveTo(36,14,36,18); ctx.quadraticCurveTo(34,22,28,24); ctx.quadraticCurveTo(18,26,8,24); ctx.closePath(); ctx.fill();
    // horn
    ctx.beginPath(); ctx.moveTo(30,10); ctx.lineTo(38,6); ctx.lineTo(34,10); ctx.fill();
  }
  ctx.restore();
}

function gameOver(){
  game.running = false;
  overlayBox.style.display = 'block';
  const overlayTextEl = document.getElementById('overlayText');
  const nameEntry = document.getElementById('nameEntry');
  const pressEl = document.getElementById('overlayPress');
  overlayTextEl.textContent = `${t('gameOver')} ${game.score}`;
  // highscore logic: show name input only if this is a new highscore
  const hs = loadHighscore();
  if(game.score > (hs.score || 0)){
    if(nameEntry) nameEntry.style.display = 'block';
    if(pressEl) pressEl.textContent = t('newHighScorePrompt');
    // focus input
    setTimeout(()=>{ const ni = document.getElementById('nameInput'); if(ni) ni.focus(); }, 80);
  } else {
    if(nameEntry) nameEntry.style.display = 'none';
    if(pressEl) pressEl.textContent = t('pressSpace');
  }
  // pick a different animal next time
  const old = animalId;
  let tries = 0;
  do { animalId = Math.floor(Math.random()*animals.length); tries++; } while(animalId === old && tries < 10);
  setBackgroundForAnimal(animalId);
}

requestAnimationFrame(loop);
dbg('requested animation frame');
// hook up name save button
const saveBtn = document.getElementById('saveNameBtn');
if(saveBtn){
  saveBtn.addEventListener('click', ()=>{
    const ni = document.getElementById('nameInput');
    const name = ni && ni.value ? ni.value.trim() : 'Player';
    if(name){ saveHighscore(name, game.score); document.getElementById('nameEntry').style.display='none'; document.getElementById('overlayPress').textContent='Press SPACE to play again'; }
  });
}
// support pressing Enter in the name field
const nameField = document.getElementById('nameInput');
if(nameField){ nameField.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); const btn = document.getElementById('saveNameBtn'); if(btn) btn.click(); } }); }

// logo fallback: if `logo.png` is missing hide the element so it doesn't show a broken image
const logoEl = document.getElementById('siteLogo');
if(logoEl){ logoEl.onerror = ()=>{ try{ logoEl.style.display = 'none'; }catch(e){} }; }
// ensure fun facts layout is correct on first paint
setTimeout(()=>{ try{ layoutFunFacts(); }catch(e){} }, 120);

// language switch handlers
const btnEn = document.getElementById('langEn');
const btnIt = document.getElementById('langIt');
function updateLangUI(){
  // toggle button styles
  if(btnEn) btnEn.style.background = currentLang === 'en' ? '#1a73e8' : (currentLang === 'it' ? 'transparent' : 'transparent');
  if(btnEn) btnEn.style.color = currentLang === 'en' ? '#fff' : '#000';
  if(btnIt) btnIt.style.background = currentLang === 'it' ? '#1a73e8' : 'transparent';
  if(btnIt) btnIt.style.color = currentLang === 'it' ? '#fff' : '#000';
  // update fun-fact title
  const titleEl = document.getElementById('funFactTitleText'); if(titleEl) titleEl.textContent = t('didYouKnow');
}
if(btnEn) btnEn.addEventListener('click', ()=>{ currentLang='en'; updateLangUI(); // reload facts in new language
  setFunFactForIndex(SINGLE_PARK_INDEX); startFunFacts(); });
if(btnIt) btnIt.addEventListener('click', ()=>{ currentLang='it'; updateLangUI(); setFunFactForIndex(SINGLE_PARK_INDEX); startFunFacts(); });
updateLangUI();
</script>
</body>
</html>